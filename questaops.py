# -*- coding: utf-8 -*-
"""QuestaoPS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c_cv7IcCmDL4bZX3NscKO7h6X22jM2I8

# QUESTÃO 1
"""

from math import fabs
def sono_ideal(horas, min):
  '''
  sono_ideal(horas, min) <- int, int
  Essa função recebe o horário em que o usuário foi dormir e retorna 6 horários diferentes, cada um referente a um ciclo de 90 min de sono.
  '''
  ciclos = []                   # Lista que vai receber os horários de cada ciclo

  if (horas < 0) or (min < 0):  # Toma o valor absoluto caso o usuário digite um valor negativo
    min = int(fabs(min))
    horas = int(fabs(horas))

  for i in range(0,6):          # Laço para criar 6 ciclos de sono
    min = min + 90              # Adiciona 90 minutos no horario que o usuário foi dormir
    while min >= 60:            # Corrige o novo horário evitando minutos > 59
      min = min - 60
      horas = horas + 1

    if horas >= 24:             # Corrige o novo horário evitando horas > 23
      while horas > 23:
        horas = horas - 24

    ciclos.append(f'{horas}h{min}min')      # Adiciona o novo horário corrigido a lista 'ciclos'

  return ciclos         # Retorna a lista com os horários


# Teste do funcionamento da função

load = 'sim'

while load == 'sim':

  print('Bem vindo(a) à calculadora de ciclos de sono ideal!\n')

  print('Primeiramente, digite o horário que deseja dormir em 2 etapas: 1º Hora, 2º Minuto.\n')
  h = int(input('Hora: '))          # Recebe as horas que o usuário foi dormir
  m = int(input('Minutos: '))       # Recebe os minutos que o usuário foi dormir

  var = sono_ideal(h, m)            # Aplica a função 'sono_ideal()'

  print(f'''\nSeu ciclo de sono ideal é:
      * Primeiro ciclo: {var[0]}
      * Segundo ciclo: {var[1]}
      * Terceiro ciclo: {var[2]}
      * Quarto ciclo: {var[3]}
      * Quinto ciclo: {var[4]}
      * Sexto ciclo: {var[5]}''')

  load = input('Você deseja fazer uma nova consulta? [sim/nao]\n')

"""# QUESTÃO 2"""

from math import exp, factorial
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-3,3)   # Define o intervalo de exibição de valores no eixo x

# Função original:
y = np.exp(x)   # Define a função y (ou f(x)) em NumPy
plt.figure(figsize=(16, 6))   # Ajusta as dimensões do gráfico para melhor visualização
plt.plot(x, y, label="Função original: $f(x) = e^x$", color="red")    # Cria o gráfico de linha de f(x)

# Polinômio de Taylor de grau 3:
p3 = exp(0) + exp(0)*(x) + exp(0)*(x)**2/factorial(2) + exp(0)*(x)**3/factorial(3)     # Define a função polinomial de Taylor de grau 3 em NumPy
plt.plot(x, p3, label="Polinômio de 3º grau: $P_3(x)$", color="green")    # Cria o gráfico de linha de P3 em função de x

# Polinômio de Taylor de grau 6:
p6 = exp(0) + exp(0)*(x) + exp(0)*(x)**2/factorial(2) + exp(0)*(x)**3/factorial(3) + exp(0)*(x)**4/factorial(4) + exp(0)*(x)**5/factorial(5) + exp(0)*(x)**6/factorial(6)   # Define a função polinomial de Taylor de grau 6 em NumPy
plt.plot(x, p6, label="Polinômio de 6º grau: $P_6(x)$", color="blue")    # Cria o gráfico de linha de P6 em função de x

plt.title("Aproximação de Taylor")   # Adiciona um título ao gráfico
plt.xlabel("x")   # Adiciona um rótulo ao eixo x
plt.ylabel("f(x)")    #  Adiciona um rótulo ao eixo y
plt.legend()    # Adiciona legenda ao gráfico
plt.grid()    # Adiciona grade ao gráfico para melhor visualização
plt.show()    # Exibe os gráficos de linha definidos nas funções plt

"""# QUESTÃO 3"""

import numpy as np
from random import randrange

def monitor(lin, col, pixels):
  '''monitor(lin, col, pixels) <- int(>=0), int(>=0), int(>=0 e <=100)
  Função que cria uma matriz com 0's e, depois, troca as entradas por 1's com base numa certa porcentagem.'''

  # Cria uma matriz com 'lin' linhas e 'col' colunas, onde todas as entradas são zero.
  matriz = np.zeros((lin, col))

  # Recebe a porcentagem e uso para saber a quantidade de entradas a serem trocadas por 1
  if pixels >= 1 and pixels <= 100:
    pixels = pixels / 100
    qnt_ent = lin * col                       # Quantidade de entradas da matriz
    qnt_pix = int(pixels *qnt_ent)            # Quantidade de pixels a serem ligados (parte inteira)

  else:
    return print('Erro! A terceira entrada deve ser um valor entre 0 e 100. Tente novamente!')

  #Caso o Usuário digite valores negativos para linhas e colunas.
  if lin <= 0 or col <= 0:
    return print('Erro! Os valores de Linhas e Colunas têm que ser positivos!')

  # Criar uma lista aleatória de índices que existem na minha matriz de zeros evitando a repetição. Uso a biblioteca random para ajudar nesse processo.
  lista = []
  i = 0
  while i < qnt_pix :
    l = randrange(0, lin)
    c = randrange(0, col)
    laux = [l, c]
    if (laux in lista) == False:              # Impede que um mesmo índice se repita
      lista.append(laux)
      i = i + 1

  # Troca os 'zeros' por 'uns' na matriz de zeros com base nos índices aleatórios
  for i in range(0, qnt_pix):
    l_ind = lista[i][0]
    c_ind = lista[i][1]
    matriz[l_ind][c_ind] = 1                  # Troca os 0's por 1's com base nos índices aleatórios gerados

  return print(matriz)                      # Retorno um print pois, se eu chamar apenas a matriz, ela retorna com a palavra 'array' aparecendo.


#____________ Teste
monitor(10,10,17)

"""# QUESTÃO 4
### Importação e tratamendo dos dados
"""

import pandas as pd
import numpy as np

# IMPORTAÇÃO DOS DADOS EM CSV:
csv_file = '/content/Dados experimentais - dados_experimentais.csv'
df = pd.read_csv(csv_file)
print("\033[1;4mDados importados do arquivo CSV\033[0m: \n", '\n', df, '\n','\n')


# RETIRAR A COLUNA "DADOS ALEATÓRIOS":
df = df.drop('dados aleatorios', axis = 1)
print("\033[1;4mDados após limpeza de valores aleatórios\033[0m: \n", '\n', df, '\n','\n')


# ADICIONAR COLUNA TEMPO:

  # Definição do tempo total de duração da coleta de dados: 4 horas + 15 min
h = 4 + 1/4   # Tempo de duração em horas
m = h*60      # Tempo de duração em minutos
s = m*60      # Tempo de duração em segundos
print(f'\033[4mTempo total (min)\033[0m: {m}')
print('\033[4mTempo total (s)\033[0m:', s,'\n')

  # Definição dos intervalos de tempo entre cada coleta de dados:
intervalo_s = 60               # Intervalo em segundos  (definição do "STEP" da sequência numérica temporal)
intervalo_m = intervalo_s/60   # Intervalo em minutos  (definição do "STEP" da sequência numérica temporal)

num_linhas = len(df)    # Leitura do nº de linhas do DataFrame (definição do "STOP" da sequência numérica temporal)
print('\033[4mNº de linhas totais\033[0m: ', num_linhas,'\n', '\n')

  # Criação das colunas referentes ao tempo:
coluna_tempo_m = pd.RangeIndex(start = 0, stop = num_linhas*intervalo_m, step = intervalo_m)   # Criação da sequência numérica temporal em minutos
df['Tempo (min)'] = coluna_tempo_m    # Adição da sequência numérica temporal em minutos como uma coluna no DataFrame
coluna_tempo_s = pd.RangeIndex(start = 0, stop = num_linhas*intervalo_s, step = intervalo_s)   # Criação da sequência numérica temporal em segundos
df['Tempo (s)'] = coluna_tempo_s    # Adição da sequência numérica temporal em segundos como uma coluna no DataFrame
print("\033[1;4mDados após adição de colunas de tempo\033[0m: \n", '\n', df,'\n','\n')


# LIMPEZA FINA DOS DADOS: Remover linhas com valores não numéricos ("NaN")
df = df.dropna()
print("\033[1;4mDados após limpeza fina\033[0m: \n", '\n', df,'\n')

"""# QUESTÃO 4
### Análise dos dados
"""

# MÉDIA DA CONCENTRAÇÃO:
media_conc = df['Concentração (mol/L)'].mean()
print(f"\033[1;4mMédia da concentração\033[0m (mol/L): {media_conc:.2f}",'\n','\n')


# MAIOR CONCENTRAÇÃO OBTIDA:
maior_conc = df['Concentração (mol/L)'].max()
print(f"\033[1;4mMaior concentração\033[0m (mol/L): {maior_conc}",'\n')

  # Obter a minutagem correspondente em múltiplas ocorrências:
df['Concentração (mol/L)'] == maior_conc    # Condição booleana para identificar as linhas em que a concentração é igual ao maior valor
linhas_maior_conc = df[df['Concentração (mol/L)'] == maior_conc]    # Filtra todas as linhas que atendem à condição

  # Conversão da coluna "Tempo (min)" das linhas filtradas em uma lista contendo todos os tempos correspondentes ao maior valor de concentração
tempo_correspondente_max = linhas_maior_conc['Tempo (min)'].tolist()
print("Minutagens correspondentes:", tempo_correspondente_max,'\n','\n')


# MENOR CONCENTRAÇÃO OBTIDA:
menor_conc = df['Concentração (mol/L)'].min()
print(f"\033[1;4mMenor concentração\033[0m (mol/L): {menor_conc}",'\n')

  # Obter a minutagem correspondente em múltiplas ocorrências:
df['Concentração (mol/L)'] == menor_conc    # Condição booleana para identificar as linhas em que a concentração é igual ao menor valor
linhas_menor_conc = df[df['Concentração (mol/L)'] == menor_conc]    # Filtra todas as linhas que atendem à condição

  # Conversão da coluna "Tempo (min)" das linhas filtradas em uma lista contendo todos os tempos correspondentes ao menor valor de concentração
tempo_correspondente_min = linhas_menor_conc['Tempo (min)'].tolist()
print("Minutagens correspondentes:", tempo_correspondente_min,'\n','\n')


# VALORES DE CONCENTRAÇÃO MAIS REPETIDOS:
valores_mais_repetidos = df['Concentração (mol/L)'].value_counts()  # Retorna uma série com os valores ordenados em ordem decrescente de frequência (e sua respectiva frequência)
print(valores_mais_repetidos.head(),'\n')   # Mostra apenas os primeiros valores da série (ou seja, os maiores)


# VALORES DE CONCENTRAÇÃO MENOS REPETIDOS:
valores_menos_repetidos = df['Concentração (mol/L)'].value_counts(ascending=True)   # Retorna uma série igual ao item anterior, porém em ordem crescente
print(valores_menos_repetidos.head(),'\n','\n')  # Mostra apenas os primeiros valores da série (ou seja, os menores)


# TAXA DE VARIAÇÃO MÉDIA DA CONCENTRAÇÃO AO LONGO DO TEMPO:
variacao_percentual = df['Concentração (mol/L)'].pct_change()   # Série de variações percentuais entre as concentrações medidas
print("\033[1;4mVariações percentuais\033[0m: \n", variacao_percentual, '\n','\n')
taxa_variacao_media = variacao_percentual.mean()   # Média das variações percentuais
print(f"\033[1;4mTaxa de variação média\033[0m: {taxa_variacao_media:.4f}",'\n','\n')


# DESVIO PADRÃO DA CONCENTRAÇÃO:
desvio_padrao = df['Concentração (mol/L)'].std()
print(f"\033[1;4mDesvio padrão\033[0m: {desvio_padrao:.2f}",'\n','\n')


# TABELA pH x CONCENTRAÇÃO:
tabela_ph_concentracao = df[['pH', 'Concentração (mol/L)']]
print("\033[1;4mTabela pH x Concentração\033[0m:",'\n', tabela_ph_concentracao,'\n','\n')


# MATRIZ DE CORRELAÇÕES ENTRE AS VARIÁVEIS MEDIDAS:
correlacao = df[['Concentração (mol/L)', 'pH', 'Temperatura (°C)']].corr()
print("\033[1;4mMatriz de correlação entre as variáveis medidas\033[0m:",'\n', correlacao,'\n')

# Representação gráfica da matriz de correlações:
import matplotlib.pyplot as plt  # biblioteca de plotagem de gráficos
import seaborn as sns     # biblioteca de visualização de dados baseada em matplotlib que oferece uma interface de nível mais alto

plt.figure(figsize=(8, 4))  # Tamanho da figura
sns.heatmap(correlacao, annot=True, cmap='coolwarm', linewidths=0.5)  # Gráfico de calor da matriz de correlação (heatmap) para melhor visualização da matriz de dados

plt.title('Mapa de Calor da Matriz de Correlação')
plt.show()


# VARIAÇÃO DA CONCENTRAÇÃO EM MOL/L AO LONGO DO TEMPO:
plt.figure(figsize=(20, 6))  # Tamanho da figura
plt.plot(df['Tempo (min)'], df['Concentração (mol/L)'])
plt.xlabel('Tempo (min)')
plt.ylabel('Concentração (mol/L)')
plt.title('Variação da concentração em mol/L ao longo do tempo')
plt.show